---
title: "RNAseq data summary"
# author: "Coby McDonald"
date: "Last Updated: `r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: true
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
start_time <- Sys.time()
```


```{r, message=FALSE, eval=T, echo=F}
library(tidyverse)
library(here)
# dir.create("outputs/001", recursive = TRUE, showWarnings = FALSE) #no longer using this structure since I'm trying to use snakemake
```

## Overview
We have 39 RNAseq libraries from the following samples (start a summit session and use opt+cmd+return to send to terminal):
```{bash, eval=F} 
ls /scratch/summit/camcd@colostate.edu/felv_rnaseq/data/samples/
```

Samples are named such as: `4438_S1_L002_R1_001.fastq.gz` in the `data/raw` directory. L002 is common to all files and indicates sequencing lane. 001 is also common to all files and is just the standard Illumina append. S indicates sample. I could shorten all filenames in `data` like so:

```{bash, eval=F}
for fname in *.fastq.gz ; do mv "$fname" "$(echo "$fname" | sed -r 's/L002_//')" ; done
for fname in *.fastq.gz ; do mv "$fname" "$(echo "$fname" | sed -r 's/_001//')" ; done
```

However, it's best practice to __not__ rename samples. For Snakemake, a better option is to hardlink to the files, rename with tidy sample names (e.g. S001), then use input functions and wildcards on these.

### The cat genome

The most recent cat genome assembly is: [Felis_catus_9.0](https://www.ncbi.nlm.nih.gov/assembly/GCF_000181335.3/), which has a total sequence length of 2.52 Gb and 19 chromosomes.

According to the [RefSeq Annotation Report](https://www.ncbi.nlm.nih.gov/genome/annotation_euk/Felis_catus/104/), it consists of:

- Genes/psuedogenes: 35,588 (or else 31,417???)
    - 19,748 protein-coding
- mRNAs: 54,713

## Pipeline
I'd like to start using Snakemake, as recommended by Eric Anderson. In the meantime, I'll do the following pipeline with batch scripts:

1. run fastqc
1. run multiqc
1. trim
1. re-run fastqc on trimmed libraries
1. re-run multiqc on trimmed libraries
1. run STAR in quantmode
1. run OrthoFinder to restrict to cat/puma orthologs
1. restrict to genes that fall within 1Mb of LTR integration sites
1. edgeR
1. WGCNA

### fastqc + multiqc
Because fastqc assigns 250MB per cpu and I want to try using 19 cores, I requested 5GB (250 x 19 = 4750).

I submitted the [fastqc.sh](workflow/scripts/fastqc.sh) script via:

```{bash, eval=F}
sbatch workflow/scripts/fastqc.sh
```

With the `--test-only` flag first to make sure I wasn't requesting more memory than existed. This took ~2.5 hours to run. This could definitely be better optimized as a job array...

### Trimgalore

Trimgalore worked great as a loop with standard quality and read length flags. See [trimgalore_test.sh](scratch/trimgalore_test.sh).


### STAR (`quantMode`)

Ran STAR in `quantMode`, which generates gene-level quantification files. [starquant_test.sh](scratch/starquant_test.sh).

I then just used bash one-liners to compile the __unstranded__ output into a counts matrix:

```{bash, eval=F}
ls *ReadsPerGene.out.tab | paste -s - > samplenames.txt

for i in *ReadsPerGene.out.tab; do awk '{print $2}' $i > $i.unstranded; done

cat samplenames.txt unstranded_counts.txt > unstranded_counts_matrix.txt

awk '{print $1}' X2654PLUS_S14_L002_ReadsPerGene.out.tab | paste - unstranded_counts_matrix.txt > readcountsmatrix.txt

```

__Note:__ I don't know if Elliott used a stranded library prep, so just using unstranded counts data at the moment.


### OrthoFinder (RBH analysis)

If we want to compare gene expression between our cat and panther samples, we need to restrict analysis to only orthologs. There are a number of ways to do this. Classically, we do it with a reciprocal best hit `blastp` run (blast all cat samples to puma genome, blast all puma samples to cat genome, retain only genes with hits both ways as presumptive orthologs). There are now many programs that will do this for you that are much faster than a local blast alignment. One is OrthoFinder, which uses `diamond`.

OrthoFinder requires protein fasta files for each proteome of interest, then performs an all-vs-all blast with `diamond`. An added bonus is that it also uses gene trees to infer orthology, which is more rigorous than some other approaches.

I'm following this [tutorial](https://davidemms.github.io/orthofinder_tutorials/running-an-example-orthofinder-analysis.html).

1. download the proteomes (see config file) and unzip
1. get only primary transcript using OrthoFinder python script: ```for f in *.faa ; do python primary_transcript.py $f ; done```
1. run OrthoFinder: ```orthofinder -f primary_transcripts/```

OrthoFinder creates a results dir called ‘OrthoFinder’ inside the input proteome directory. For the RBH, we basically only care about Orthologues output.

__Troubleshooting:__
For some reason, the standard tutorial code isn't working. The ortholog file, which should have three columns (orthogroup, plus one column of cat proteins, one column of puma proteins) has puma protein identifiers in *both* the cat and puma column...

I'm trying to re-run it after cleaning the fastas generated after running the `primary_transcript.py` script. The tutorial cleaned fastas just have the protein identifier, then the sequence. Mine had the protein identifier, then the protein name, then the species in brackets. The following sed removes everything after the protein identifier.

```{bash, eval=F}
sed 's/\s.*$//' GCF_000181335.3_Felis_catus_9.0_protein.faa > GCF_000181335.3_Felis_catus_9.0_protein.cleaned.faa

sed 's/\s.*$//' GCF_003327715.1_PumCon1.0_protein.faa > GCF_003327715.1_PumCon1.0_protein.cleaned.faa
```

From here, I'm re-running [orthofinder_test.sh](scratch/orthofinder_test.sh)

...Annnnd that didn't work. I don't understand why it's messing up the names! Try renaming the fasta files??? There's no way that will change anything...

It looks like the tutorial dataset uses BLAST instead of Diamond. Maybe that's somehow having an effect??

Actually...I'm dumb it is working...it's just that some of the felis refseq ids start with XP, while all of the puma ids do, so I thought it was assigning puma ids to felis ugggghhh.

__Quality control:__
Looking at the statistics files, we see that only ~50% of cat genes are assigned to orthogroups whereas 90% of FP genes are. Anything under 80% indicates poor species sampling. This is...unexpected! I would have assumed the opposite. However, the cat genome is apparently 54,726 genes, and there's no way cats have that many true genes. Sue mentioned that the cat genome was notoriously bad...(I asked Michelle and she said there are lots of reasons for this: genotyping array is still only 100K when a 600K array has been promised for a decade, there's not a lot of money/industry money is in the hands of people who aren't the best at genetics, cats are all mutts so imputation is harder, etc.).

Other methods of QC are to look at the gene trees and the gene duplication events to make sure they make sense...because we only have two species, I don't think the trees are really going to show anything useful.

__Ortholog file:__ Since most of our samples are cats and we only have one panther, it makes more sense to use the cat ortholog file than the panther ortholog file.

Once this is finished, I'll filter the respective read counts matrices to only orthologs, and combine for DGE analysis.

The ortholog file lists protein IDs, and I need to convert to gene IDs:

The easiest way to do this is to read the gtf file into R and use `rtracklayer`:

```{r, eval=T, echo=F}
library(rtracklayer)
gtf <- rtracklayer::import("results/orthofinder/GCF_000181335.3_Felis_catus_9.0_genomic.gtf")
gene_tran_pro <- as.data.frame(mcols(gtf)[,c("gene_id","transcript_id","protein_id")])
```

Then, I can get a list of cat orthologs (protein_id) plus gene_id:
```{r, eval=T, echo=F, message=F}
orthologs <- read_delim("results/orthofinder/GCF_000181335.3_Felis_catus_9.0_protein__v__GCF_003327715.1_PumCon1.0_protein.csv", delim="\t", col_names = c("Orthogroup","Cat_protein_id","puma_protein_id"), skip = 1) %>% 
  separate_rows(Cat_protein_id, convert=TRUE, sep = ", ")

ortho_and_gene <- left_join(orthologs, gene_tran_pro, by=c("Cat_protein_id"="protein_id")) %>%
  select(gene_id) %>% 
  distinct()
```

There are multiple proteins derived from each gene.

```{r, eval=T, echo=T, message=F}
dat <- read_delim("readcountsmatrix.txt", delim = "\t") %>% select(-DC2Pool, -DC3Pool)
counts <- dat[-c(1:4, 31498),]

counts_w_protein <- left_join(ortho_and_gene, counts, by=c("gene_id"="genes"))

counts_ortho_only <- counts_w_protein %>% 
  #select(-Cat_protein_id, -transcript_id) %>% 
  distinct() %>% 
  drop_na()
write_delim(counts_ortho_only, "results/orthofinder/genecounts_orthologs.txt", delim="\t")
```

### ID genes 1 Mb up and downstream of LTR integration sites

After restricting to orthologs, we can further restrict our gene set to only those genes that are within 1 Mb of the ~700 LTR integration sites that Elliott identified.

Using [Supplemental Table 1](data/Supplemental Table 1 Run 2 Curated integration sites.xlsx) from Elliott's integration site manuscript, I extracted LTR start sites, then [generated a list of chromosomal regions +/- 1 Mb](data/LTR_allsites_upanddown.txt).

I used this list of defined regions (which is in bed format) to query the [UCSC Table Browser](http://genome.ucsc.edu/cgi-bin/hgTables) to extract all genes within these windows.

```{r, eval=F, message=F}
library(tidyverse)
LTR_genes <- read_delim("data/felCat9_1Mb_LTRsites_all.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()

LTR_genes %>% summarise(n())
```

Based on the genes extracted from UCSC, it appears there are 31,076 genes within 1 Mb of an LTR integration site. This is essentially the entire genome! Thus, it's not going to give us any more specific results than we already have. Options for parsing this out better:

__1. Restrict to <1 Mb up and downstream.__
  
    - The 1 Mb decision was because this is the maximum distance for LTR enhancer function. We could instead look just at promoter function? What would this distance be?
    
__2. Pick out particularly interesting integration sites and look only at those.__

    - For example, only the integration sites found in >10 cats
    - __I'll use this second approach__
    
#### Interesting integration sites

__1. Fibroblasts: infected vs. uninfected__
Restrict to LTR sites present in ≥3 (out of 4) fibroblast samples = [78 LTR sites](data/LTR_fibro_upanddown.txt)

```{r, eval=F, echo=F}
library(rtracklayer)
gtf <- rtracklayer::import("results/orthofinder/GCF_000181335.3_Felis_catus_9.0_genomic.gtf")
gene_tran_pro <- as.data.frame(mcols(gtf)[,c("gene_id","transcript_id","protein_id")])

library(tidyverse)
LTR_fibro <- read_delim("data/felCat9_1Mb_LTRsites_fibro.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()
LTR_fibro_genid <- left_join(LTR_fibro, gene_tran_pro, by=c("X4"="transcript_id")) %>% 
  select(-protein_id, -X4) %>% 
  distinct()

# write_tsv(LTR_fibro_genid, "data/LTR_fibro_genids.txt")
```

This doesn't yield any interesting genes...

__2. PMBCs: present vs absent__
Restrict to LTR sites present in 3 (out of 6) PMBC samples = [42 sites](data/LTR_pmbc_upanddown.txt)

```{r, eval=F, echo=F}
LTR_pmbc3 <- read_delim("data/felCat9_1Mb_LTRsites_pmbc3.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()
LTR_pmbc3_genid <- left_join(LTR_pmbc3, gene_tran_pro, by=c("X4"="transcript_id")) %>% 
  select(-protein_id, -X4) %>% 
  distinct()

write_tsv(LTR_pmbc3_genid, "data/LTR_pmbc3_genids.txt")

LTR_pmbc2 <- read_delim("data/felCat9_1Mb_LTRsites_pmbc2.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()
LTR_pmbc2_genid <- left_join(LTR_pmbc2, gene_tran_pro, by=c("X4"="transcript_id")) %>% 
  select(-protein_id, -X4) %>% 
  distinct()

write_tsv(LTR_pmbc2_genid, "data/LTR_pmbc2_genids.txt")

LTR_pmbc1 <- read_delim("data/felCat9_1Mb_LTRsites_pmbc1.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()
LTR_pmbc1_genid <- left_join(LTR_pmbc1, gene_tran_pro, by=c("X4"="transcript_id")) %>% 
  select(-protein_id, -X4) %>% 
  distinct()

write_tsv(LTR_pmbc1_genid, "data/LTR_pmbc1_genids.txt")

LTR_over10 <- read_delim("data/felCat9_1Mb_LTRsites_over10cats.txt", delim="\t", skip = 1, col_names = F) %>% 
  select(X4) %>% 
  distinct()
LTR_over10_genid <- left_join(LTR_over10, gene_tran_pro, by=c("X4"="transcript_id")) %>% 
  select(-protein_id, -X4) %>% 
  distinct()

write_tsv(LTR_over10_genid, "data/LTR_over10_genids.txt")
```

__Set1:__ 15 sig genes; no sig LTR genes
__Set2:__ 51 sig genes; not sig LTR genes
__Set3:__ 1 significant gene; no significant LTR genes


__3. Present in ≥10 cats__
Restrict to sites only found in ≥10 cats in Elliott's larger study = [87 sites](data/LTR_over10cats_upanddown.txt)

But then for this, what groups would I compare? There are no clear groupings where this would work, except for PMBCs vs. fibroblasts, which is super confounded...

__3a. Compare PMBCs vs fibroblasts:__ 
When restricting to genes 1Mb from LTR insertion sites present in >10 cats, there are 687 significant genes. But, this isn't meaningful at all! The sites that are present in >10 cats may or may not be present in the PMBC and fibroblast samples.If they aren't present in one or the other, then the expression could be due to cell type or LTR presence/absence and there's no way to tell. Need to: a) restrict to only LTR sites present in BOTH, b) bin PMBC+fibro present vs PMBC+fibro absent and re-run.

### edgeR

I used the [readcountsmatrix.txt](readcountsmatrix.txt) and the sample [metadata](data/felv_metadata.tsv) to begin edgeR analyses.

__Note:__ when restricting to smaller gene sets (e.g. 1-3 above), all normalization and model fitting must be done on the full gene set. Then at the T-test to ID significant genes, I can restrict to genes of interest to recalculate the P-values. So, because there are no significantly differentially expressed genes between infected and uninfected fibroblasts, there will be no significant genes from the restricted set #1...

#### Data exploration

Code: [DGE_dataexplore.R](workflow/scripts/DGE_dataexplore.R)

Looking at all samples, we can see that there are 31,498 genes in the full dataset. After modest filtering for sequence errors, that goes down to ~16,000 genes. Library size ranged from 2,692,910 (MischiefPlus) to 33,912,615 (DC4PLUS). 

```{r, eval=F, echo=F}
library(here)
library(tidyverse)
library(edgeR)
library(pheatmap)


#### 0. Get data ####
## counts
dat <- read_delim("readcountsmatrix.txt", delim = "\t") %>% select(-DC2Pool, -DC3Pool)
# mapping_dat <- dat[c(1:4, 31498),]
# counts <- dat[-c(1:4, 31498),]
counts <- counts_ortho_only

## metadata
meta <- read_tsv("data/felv_metadata.tsv") %>% filter(id_inf != c("DC2Pool", "DC3Pool")) %>% filter(id_inf != "DC1PLUS")
Cell_type=meta$cell_type
Infection_status=meta$status
Population=meta$population
cell_inf=paste(meta$cell_type, meta$status, sep="_")


#### 1. Create DGElist, filter by CPM, and calcNormFactors ####
## Create DGEList
dat.full <- DGEList(counts=counts[,2:16], group=cell_inf, genes = counts[,1])
# dat.full$samples$group

## Filter
keep_counts<-rowSums(cpm(counts[,2:16])>1) >= 0.25*ncol(dat) #filter >1 cpm in >= 1/2 of samples

dat.filt<-dat.full[which(keep_counts==T), , keep.lib.sizes=FALSE]
dim(dat.full)
dim(dat.filt)

dat.norm<-calcNormFactors(dat.filt)
dat.norm$samples #normalization factors and library size
```

That's way too few reads for the Mischief (puma) samples. When we look at sample correlation and a PCA, we can also see that they're way different from the other fibroblast samples, which is probably a function of poor sequencing, and is not biologically relevant? This remains true when we filter our counts matrix to only cat genes that have puma orthologs. Consider removing the Mischief samples from further analyses.

```{r, echo=F}
#### 2. Generate moderated, logCPM counts matrix for sample correlation and PCA ####
dat.logCPM <- cpm(dat.norm, log=TRUE, prior.count = 1, normalized.lib.sizes = TRUE)


#### 3. Generate sample correlation matrix and pheatmap ####
## annotate columns by tissue, treatment, and time
annotation_col1 <- data.frame(
  Cell_type,
  Infection_status,
  Population
)
rownames(annotation_col1) <- colnames(dat[,c(2:16)])

ann_colors1 = list(
  Cell_type =c(fibroblast="#008080",PBMC="#ef6079"),
  Infection_status = c(infected = "#00b6bd", uninfected = "lightgrey"),
  Population = c(outbred = "#065b9b", puma = "#c29a2b", SPF = "#83308c")
  )


## Generate pheatmap
# pdf(file="plots/sample_correlation.pdf", width=9,height=7)
pheat_samplecor <- pheatmap(cor(dat.logCPM),
                            annotation_col=annotation_col1,
                            annotation_names_col=F,
                            annotation_colors=ann_colors1,
                            annotation_row=annotation_col1,
                            annotation_names_row=F,
                            angle_col= "45",
                            border_color = NA,
                            show_rownames = F,
                            show_colnames = F
                            #cutree_cols = 3,
                            #cutree_rows=3
)
# dev.off()
```

<br>

```{r, echo=F}

#### 4. Generate PCAs, look for outliers and batch effects ####
## Generate PCA
counts.pca<-prcomp(t(dat.logCPM))
s<-summary(counts.pca)
# s$importance
scores<-as.data.frame(counts.pca$x)

Mischief <- scores[12,]
meta_mischief <- meta[12,]

## By cell type:
pca <- ggplot(data=scores, aes(x=PC1, y=PC2, group=Cell_type)) + 
  geom_point(aes(color=Infection_status, shape=Cell_type, size=Cell_type)) +
  scale_color_manual(values=c("#00b6bd", "lightgrey")) +
  scale_size_manual(values=c(3,3)) +
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1)) +
  theme(panel.background = element_blank(), panel.grid = element_blank()) +
  xlab ("PC1 (69.9%)") +
  ylab ("PC2 (21.2%)") +
  guides(colour = guide_legend(override.aes = list(size=3)))
# pca
# pca + annotate("text", label=meta_mischief$population, x=Mischief$PC1, y=Mischief$PC2, size=3)
pca + annotate("text", label=meta_mischief$population, x=(-105), y=258, size=4)
# ggsave(file="plots/pca_all.eps")

```

#### Differential expression

Code: [DGE_edgeR.R](workflow/scripts/DGE_edgeR.R)

So there are a couple comparisons we can make:

- Cell type differential expression (PMBCs vs fibroblasts)
- uninfected vs. FeLV-infected differential expression (fibroblasts only)

Looking at cell type, 4510 is a big outlier, again I suspect due to poor sequencing, although Elliott says this animal has far more LTR sites than any of the other samples.

![](plots/pca_uninfected.jpg)

Expression is clearly cell-specific, which we would expect. There are ~6,000 genes significantly differentially expressed between fibroblasts and PMBCs.

Looking at FeLV infection status, we see that infection status plays a pretty negligible role:

![](plots/pca_felv_status.jpg)
Samples cluster according to biological replicate and not according to infection status. Thus, we end up with only 3 significantly DE genes, all of which are uncharacterized proteins.
